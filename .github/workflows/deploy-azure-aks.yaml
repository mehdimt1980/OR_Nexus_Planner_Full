name: Deploy to Azure AKS

on:
  push:
    branches: [ main ]
  workflow_dispatch:

env:
  RESOURCE_GROUP: nexus-or-planner-rg
  AKS_CLUSTER: nexus-or-planner-aks
  ACR_NAME: nexusorplanneracr
  IMAGE_NAME: nexus-or-planner
  LOCATION: westeurope

jobs:
  setup-azure-resources:
    runs-on: ubuntu-latest
    outputs:
      acr-login-server: ${{ steps.acr-login.outputs.acr_login_server }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Azure Login
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}

    - name: Create Resource Group
      run: |
        az group create --name ${{ env.RESOURCE_GROUP }} --location ${{ env.LOCATION }}

    - name: Create Azure Container Registry
      run: |
        az acr create \
          --resource-group ${{ env.RESOURCE_GROUP }} \
          --name ${{ env.ACR_NAME }} \
          --sku Basic \
          --admin-enabled true

    - name: Create AKS Cluster
      run: |
        az aks create \
          --resource-group ${{ env.RESOURCE_GROUP }} \
          --name ${{ env.AKS_CLUSTER }} \
          --node-count 2 \
          --node-vm-size Standard_B2s \
          --enable-addons monitoring \
          --generate-ssh-keys \
          --attach-acr ${{ env.ACR_NAME }}

    - name: Get ACR login server
      id: acr-login
      run: |
        ACR_LOGIN_SERVER=$(az acr show --name ${{ env.ACR_NAME }} --resource-group ${{ env.RESOURCE_GROUP }} --query "loginServer" --output tsv)
        echo "acr_login_server=$ACR_LOGIN_SERVER" >> $GITHUB_OUTPUT

  deploy-application:
    needs: setup-azure-resources
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Azure Login
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}

    - name: Build and push Docker image
      run: |
        az acr login --name ${{ env.ACR_NAME }}
        docker build -t ${{ needs.setup-azure-resources.outputs.acr-login-server }}/${{ env.IMAGE_NAME }}:${{ github.sha }} .
        docker push ${{ needs.setup-azure-resources.outputs.acr-login-server }}/${{ env.IMAGE_NAME }}:${{ github.sha }}

    - name: Get AKS credentials
      run: |
        az aks get-credentials --resource-group ${{ env.RESOURCE_GROUP }} --name ${{ env.AKS_CLUSTER }} --overwrite-existing

    - name: Setup kubectl
      uses: azure/setup-kubectl@v3

    - name: Install NGINX Ingress Controller
      run: |
        helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
        helm repo update
        helm install ingress-nginx ingress-nginx/ingress-nginx \
          --create-namespace \
          --namespace ingress-nginx \
          --set controller.service.annotations."service\.beta\.kubernetes\.io/azure-load-balancer-health-probe-request-path"=/healthz

    - name: Wait for ingress controller
      run: |
        kubectl wait --namespace ingress-nginx \
          --for=condition=ready pod \
          --selector=app.kubernetes.io/component=controller \
          --timeout=300s

    - name: Create namespace and secrets
      run: |
        kubectl create namespace nexus-or-planner --dry-run=client -o yaml | kubectl apply -f -
        kubectl create secret generic nexus-or-planner-secrets \
          --from-literal=GOOGLE_API_KEY="${{ secrets.GOOGLE_API_KEY }}" \
          --namespace=nexus-or-planner \
          --dry-run=client -o yaml | kubectl apply -f -

    - name: Deploy to AKS
      run: |
        # Update the image in the manifest
        sed "s|<ACR_NAME>|${{ env.ACR_NAME }}|g" kubernetes-manifests.yaml > k8s-deploy.yaml
        sed -i "s|:latest|:${{ github.sha }}|g" k8s-deploy.yaml
        
        # Apply the manifest
        kubectl apply -f k8s-deploy.yaml
        
        # Wait for deployment
        kubectl wait --for=condition=available --timeout=300s deployment/nexus-or-planner -n nexus-or-planner

    - name: Get external IP
      run: |
        echo "Waiting for external IP..."
        sleep 60
        EXTERNAL_IP=$(kubectl get svc --namespace ingress-nginx ingress-nginx-controller --template="{{range .status.loadBalancer.ingress}}{{.ip}}{{end}}")
        echo "External IP: $EXTERNAL_IP"
        echo "Your application will be available at: http://$EXTERNAL_IP"
